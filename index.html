<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
        <style type="text/css">
            .reveal h1,
            .reveal h2,
            .reveal h3,
            .reveal h4,
            .reveal h5,
            .reveal h6 {
                text-transform: none;
            }
            .reveal li {
                line-height: 1.7em;
            }

            .reveal p {
                font-size: 80%;
            }
        </style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3 style="text-transform: none ">React-Native技术介绍</h3>
					<p>
						<small>Created by <a href="mailto:zhoudan1@staff.sina.com.cn">周丹</a> / @sina</small>
					</p>
                    <aside class="notes">

                    </aside>
				</section>
                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## react-naitve诞生的背景
                            <br>
                            - 现代Web开发技术的兴起

                            - 移动App开发的挑战

                            - Nodejs成为全栈王者


                            Note:
                            ### 移动开发技术历史
                            我们把时光回到7年前
                            - 09年, Symbian退出历史舞台,ios系统问世,颠覆了大家对手机的认识
                            - 09年, js基础库框架解决了浏览器兼容问题,以及js代码的标准写法
                            - 09年5月份, nodejs的作者Ryan Dahl(瑞恩.达尔)为了搭建一个轻量级的web服务器,用v8引擎做出了nodejs的第一版本,并发布到github上
                        </script>
                    </section>
                    <section>
                        <h3>现代Web开发技术的兴起</h3>
                        <br>
                        <p>JavaScript、ES6、JSX、Babel、NodeJS、NPM、Grunt、Bower、ReactJs、WebPack、Flux、Redux、Immutable、Angular、TypeScript、Service workers、Less、Sass ...</p>
                        <img height="300" src="imgs/starwar.jpg" >

                        <aside class="notes">
                            - ES6的大范围普及
                            - 前端开发的工程化进化
                            - 得益于移动设备的高起点对PC的倒逼
                        </aside>

                    </section>
                    <section>
                        <h3>移动App开发的挑战</h3>
                        <br>
                        <ul style="font-size: 70%;">
                            <li>ios和android双平台</li>
                            <li>开发编译巨慢</li>
                            <li>版本迭代周期长</li>
                            <li>bug修复需发版本</li>
                            <li class="fragment highlight-red">开发人员成本</li>

                        </ul>
                        <p><img height="200" src="imgs/yuan.jpg" ></p>
                        <aside class="notes">
                            - 两种开发语言、两个平台、代码和解决方案都是两份, 对每个系统包含在外部的一些外延技术,也都各不相同,
                               就拿网络库来说,ios 有afnetwork, asi 等,android有 volley, okhttp,
                            - 两个环境两个编译环境, ios是xcode必须是在mac机器下编译,anroid是eclipse,现在变成 android studio,
                              稍微好一点,能在window下和mac下编译, 但是基本上打开这两个任何一个ide, 内存就吃满了。
                            - 版本开发周期, 大家都深有体会, 因为是编译开发, 所有代码都要经过代码编写、编译打包、测试通过、之后才能发布上线
                              跟传统的web开发不同, web开发基本上所见即所得, 测试也不用这么麻烦
                            - 由于是发版,基本上有问题的话,发出去的版,就没办法弥补了,一旦出现严重问题,只能通过再发版才能修复之前的问题,但是
                              就算你再发版,用户也不能立刻更新,所以,在移动开发领域有各种各样的热更新技术, ios的通过jscore做hook的jspath,
                              android通过ClassLoader机制来更新dex,还有用lua脚本来处理的,等等等很多,都是解决这个问题
                        </aside>

                    </section>
                    <section>
                        <h3>Nodejs成为全栈王者</h3>
                        <br>
                        <blockquote>" PHP是世界上最好的语言，但JavaScript终将统一全宇宙 "</blockquote>
                        <aside class="notes">
                            1、NodeJs最近2年飞速发展,颠覆了很多技术领域,前端就不用说了,后端用来写server,利用基于事件的异步编程
                               支持大量连接,到现在开发App也离不开它
                            2、现在NodeJs的代码仓库NPM,保存的代码量已经超越所有其他语言的代码量
                        </aside>
                    </section>
                </section>
                <section data-background="#4d7e65">
                    <section>
                        <h2>ReactJs介绍</h2>
                        <br>
                        <p><img width="300" data-src="imgs/reactjs.svg"></p>
                        <aside class="notes">
                            1、最新的react-native版本 0.30,已经把reactjs和react-native拆分清楚,只不过react-native依赖reactjs
                            2、想要很好的理解和学习react-native,必须要从reactjs下手,因为facebook官方默认你已经对reactjs是熟悉的,
                            例如component的生命周期,jsx的语法,props和state的关系一起区别,stateless和stateful的component的区别
                        </aside>
                    </section>
                    <section>
                        <h3>ReactJs和React-Native什么关系</h3>
                        <br>
                        <p style="text-align: left">React-Native是ReactJs在App上的<span style="color:greenyellow ">移植版</span>,两者都是由js实现的虚拟dom来驱动界面view层渲染,只不过ReactJs是驱动HtmlDom渲染, React-Native是驱动android/ios原生组件渲染</p>
                        <aside class="notes">
                            1、想要很好的理解和学习react-native,必须要从reactjs下手,因为facebook官方默认你已经对reactjs是熟悉的,
                            例如component的生命周期,jsx的语法,props和state的关系一起区别,stateless和stateful的component的区别
                        </aside>
                    </section>
                    <section>
                        <h3>ReactJs - Features</h3>
                        <br>
                        <ul>
                            <li>reactive式显示View</li>
                            <li>模块化、可组装的组件</li>
                            <li>数据沿着组件树从上至下单向流动</li>
                        </ul>
                        <p style="text-align: right"><a target="_blank" href="https://jsfiddle.net/reactjs/69z2wepo/">示例</a></p>
                        <aside class="notes">
                            1、不是传统的绑定式更新,会对每个action做单独处理,当数据量变大时,结构就失去清晰
                            2、reactjs本身就是以component的方式render的,天生有利于代码复用,这样方便代码维护,写出高质量代码
                            3、reactjs摒弃双向数据绑定,让数据只向一个方向更新,减少复杂度和出错概率
                        </aside>
                    </section>
                    <section>
                        <h3>ReactJs - Component</h3>
                        <p><a target="_blank" href="imgs/component.jpg"><img height="550" data-src="imgs/component.jpg"></a></p>
                        <aside class="notes">
                        </aside>
                    </section>
                    <section>
                        <h3>ReactJs -  注意事项</h3>
                        <ul>
                            <li>基于props和state的数据沿着组件树从上至下单向流动</li>
                            <li>stateless 和 stateful 组件的拆分</li>
                            <li>state应该包含最小量的合理数据来反应你的UI</li>
                        </ul>
                        <aside class="notes">
                            1、严格准守数据的单项流动
                            2、你的大部分组件仅仅是拿到props数据,render完成就ok了,有时候你要处理用户的input,以及服务器的返回数据
                               这个时候你才需要用到stateful的组件,即有state属性。常规模式是,创建一个stateful的container组件来和
                                外部数据打交道,内部封装一些只接受props的组件作为stateless组件,stateful包含业务逻辑代码,
                                stateless只负者显示
                            3、state不应该包含计算过的数据、其他component组件、以及从props复制过来的数据
                        </aside>
                    </section>
                </section>

                <section  data-transition="slide" data-background="#b5533c" data-background-transition="zoom">
                    <section>
                        <h3>React-Native</h3>
                        <br>
                        <blockquote style="font-size: 70%">
                            " Build Native Mobile Apps using JavaScript and React, <br>
                            React Native lets you build mobile apps using only JavaScript. It uses the same design as React, letting you compose a rich mobile UI from declarative components. "

                            <br>
                            <div style="text-align: right">-- facebook</div>
                        </blockquote>
                        <aside class="notes">
                            React-Native 从ReactJs发展而来, 一些理论和方法调用都和ReactJs一致
                        </aside>
                    </section>
                    <section>
                        <h3>React-Native代码片段 </h3>
                        <pre>
                        <code class="hljs" style="font-size: 90%" data-trim contenteditable>
import React, { Component, } from 'react';
import {
  AppRegistry,
  StyleSheet,
  Text,
  View,
} from 'react-native';

class App extends Component {
  render() {
    return (
      <View style={styles.container}>
        <Text style={styles.welcome}>
          Welcome to React Native!
        </Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF',
  },
  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
  },
});

AppRegistry.registerComponent('App', () => App);
                        </code>
                        </pre>
                        <p style="text-align: right"><a target="_blank" href="http://dabbott.github.io/react-native-web-player/">示例</a></p>
                        <aside class="notes">
                        </aside>
                    </section>
                    <section>
                        <h3>React-Native 组成部分</h3>
                        <ul>
                            <li>RN 原生Modules、Components(内置、自制)</li>
                            <li>RN 非原生Js层面Components</li>
                            <li>RN 入口AppComponent</li>
                            <li>RN StyleSheet <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank">Flexbox</a></li>
                        </ul>

                        <pre>
                            <code class="hljs">
AppRegistry.registerComponent('F8v2', setup);
                            </code>
                        </pre>

                        <aside class="notes">
                            1、react-native最核心的是提供一个native 和 js之间渲染的通信机制,在此基础上,系统也提供了一些基础的Components 和 Modules
                            2、无论内置还是自制,都会按照RN提供的一套wrapper 写法来写接口文件
                            3、Js层面会依托RN系统内置支持的空间来构建
                        </aside>
                    </section>
                    <section  data-markdown>
                        <script type="text/template">
                        ### React-Native 工程创建(系统默认)

                        > 系统准备以mac+ios为例

                        ```
                        brew install node         // 安装node环境
                        brew install watchman     // 安装监听文件修改工具
                        npm install -g react-native-cli // react-native 命令行
                        ```

                        > demo工程创建

                        ```
                        react-native init AwesomeProject
                        cd AwesomeProject
                        react-native run-ios
                        ```
                        [官方](http://facebook.github.io/react-native/docs/getting-started.html)
                        </script>
                    </section>
                    <section  data-markdown>
                        <script type="text/template">
                            ### React-Native 样板工程

                            > 我们搭建的增强版样板工程

                            ```
                            git clone git@gitlab:apps/rawRNProject.git   // 检出代码
                            cd rawRNProject             // 进入工程目录
                            npm install                 // 安装依赖
                            ./server.sh                 // 启动开发服务
                            sh package_ios_all.sh      // 打包本地bundle
                            ```
                            - react-native版本切换支持   <!-- .element: style="font-size:70%"  -->
                            - 添加cplt底层c++层面跨平台支持 <!-- .element: style="font-size:70%"  -->
                            - 多bundle消息传递支持 <!-- .element: style="font-size:70%"  -->
                            - bundle的在线更新支持 <!-- .element: style="font-size:70%"  -->
                            - 新浪sso登录接口支持 <!-- .element: style="font-size:70%"  -->

                        </script>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>React-Native 实现原理</h3>
                        <p>RN需要一个JS的运行环境， 在IOS上直接使用内置的javascriptcore， 在Android 则使用webkit.org官方开源的jsc.so, 以此来把构建的虚拟DOM树给渲染出来</p>
                        <p><a target="_blank" href="imgs/framework.jpeg"><img height="400" data-src="imgs/framework.jpeg"></a></p>

                        <aside class="notes">
                            1、普通的JS-OC通信实际上很简单，
                            OC向JS传信息有现成的接口，
                            像webview提供的-stringByEvaluatingJavaScriptFromString方法可以直接在当前context上执行一段JS脚本，
                            并且可以获取执行后的返回值，这个返回值就相当于JS向OC传递信息。
                            React Native也是以此为基础，通过各种手段，实现了在OC定义一个模块方法，JS可以直接调用这个模块方法并还可以无缝衔接回调。

                            2、对于传统 Java<>Js 通信而言，
                            Js 调用 Java 通不外乎 Jsbridge、onprompt、log 及 addjavascriptinterface 四种方式，
                            在 Java 调用 Js 只有 loadurl 及高版本才支持的 evaluateJavaScript 两种。
                            但在 RN 中没有采用了传统 Java 与 Js 之间的通信机制，而是借助 MessageQueue 及模块配置表，
                            将调用转化为{moduleID, methodID，callbackID，args}，处理端在模块配置表里查找注册的模块与方法并调用。

                        </aside>
                    </section>
                    <section>
                        <h3>React-Native 运行原理</h3>
                        <p style="font-size: 65%">简化的可以理解为, Native端和JS端分别各有一个bridge，两个bridge都保存了同样一份模块配置表，JS调用Native模块方法时，通过bridge里的配置表把模块方法转为模块ID和方法ID传给Native，Native通过bridge的模块配置表找到对应的方法执行之</p>
                        <p><a target="_blank" href="imgs/query.png"><img height="400" data-src="imgs/query.png"></a></p>
                        <p style="text-align: right"><a target="_blank" href="http://blog.cnbang.net/tech/2698/">网文</a></p>
                    </section>
                    <section>
                        <h3>React-Native IOS调用原理</h3>
                        <p style="font-size: 70%">Native端和JS端分别各有一个bridge，两个bridge都保存了同样一份模块配置表，JS调用Native模块方法时，通过bridge里的配置表把模块方法转为模块ID和方法ID传给Native，同时把调用请求放到一个MessageQueue里面,并且保留CallbackID,
                            Native通过bridge的模块配置表找到对应的方法执行之,并根据保存的CallbackID进行回调</p>
                        <p><a target="_blank" href="imgs/callback.png"><img height="400" data-src="imgs/callback.png"></a></p>
                        <p style="text-align: right"><a target="_blank" href="http://blog.cnbang.net/tech/2698/">网文</a></p>
                    </section>
                    <section>
                        <h3>React-Native IOS调用原理 之 事件响应</h3>
                        <p style="font-size: 70%">上述第4步是怎么把数据传给Native的? 其实是利用了Native的事件机制</p>
                        <p><a target="_blank" href="imgs/event.png"><img height="400" data-src="imgs/event.png"></a></p>
                        <p style="text-align: right"><a target="_blank" href="http://blog.cnbang.net/tech/2698/">网文</a></p>
                    </section>
                    <section>
                        <h3>React-Native Androud调用原理</h3>
                        <p style="font-size: 70%">原理和Ios一致,不得就是实现方式不一样而已</p>
                        <p><a target="_blank" href="imgs/j2js.jpg"><img width="400" data-src="imgs/j2js.jpg"></a>
                            <a target="_blank" href="imgs/js2j.jpg"><img width="400" data-src="imgs/js2j.jpg"></a></p>
                        <p style="text-align: right"><a target="_blank" href="http://www.cnblogs.com/bugly/p/5266250.html">网文</a></p>
                    </section>
                    <section>
                        <h3>React-Native Native-Module开发</h3>
                        <p><a target="_blank" href="imgs/ios-module.png"><img height="500" data-src="imgs/ios-module.png"></a></p>
                        <p style="text-align: right"><a target="_blank" href="http://facebook.github.io/react-native/docs/native-modules-ios.html#ios-calendar-module-example">网文</a></p>
                    </section>
                </section>
                <section data-background="#4d7e65">
                    <section>
                        <h3>React-Native 应用开发</h3>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                        ### 工程管理 - cnpm

                        ```
                         echo -e '\n#alias for cnpm\nalias cnpm="npm \
                             --registry=http://10.210.227.168:7001 \
                             --cache=$HOME/.npm/.cache/cnpm \
                             --disturl=http://10.210.227.168:7002 \
                             --userconfig=$HOME/.cnpmrc"' \
                             >> ~/.bashrc && source ~/.bashrc
                        ```
                        [wiki](http://wiki.intra.sina.com.cn/pages/viewpage.action?pageId=102663061)
                        ![@app native库](/reveal.js/imgs/cnpmapp.png "@app")

                        </script>
                    </section>
                    <section>
                        <h3>redux</h3>
                        <blockquote>
                           " JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。"
                        </blockquote>
                        <ul>
                            <li>Store</li>
                            <li>Reducer</li>
                            <li>Action</li>
                            <li>Middleware、异步 ... </li>
                        </ul>
                    </section>
                    <section>
                        <h3>react-redux</h3>
                        <p>Redux 官方提供的 React 绑定库。</p>
                        <pre><code>npm install --save react-redux</code></pre>
                    </section>
                    <section>
                        <h3>redux 使用</h3>
                        <pre><code>
import { connect } from 'react-redux';
// 哪些 Redux 全局的 state 是我们组件想要通过 props 获取的？
function mapStateToProps(state) {
  return {
    value: state.counter
  };
}

// 哪些 action 创建函数是我们想要通过 props 获取的？
function mapDispatchToProps(dispatch) {
  return {
    onIncrement: () => dispatch(increment())
  };
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Counter);

....

import { Provider } from 'react-redux';
ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);

                        </code></pre>
                        <p style="text-align: right"><a target="_blank" href="http://cn.redux.js.org/docs/react-redux/quick-start.html#quick-start">文档</a></p>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>React-Native 反思</h3>
                        <ul>
                            <li>系统仍然依赖原生组件暴露出来的组件和方法</li>
                            <li>大量组件是iOS only的,不能跨平台</li>
                            <li>比较于WebApp能干的事情太多了,但是代价也很大</li>
                        </ul>
                        <aside class="notes">
                            1、ScrollView这个组件，在Native层是有大量事件的，
                            scrollViewWillBeginDragging， scrollViewWillEndDragging，scrollViewDidEndDragging等等，
                            这些事件在现有的版本都没有暴露，基本上做不了组件联动效果。

                            2、ActivityIndicatorIOS、DatePickerIOS、NavigatorIOS、PickerIOS、SliderIOS、SwitchIOS、
                            TabBarIOS、AlertIOS、AppStateIOS、LinkingIOS、PushNotificationIOS、StatusBarIOS、VibrationIOS，
                            反过来看，剩余的都是一些抽象程度极强的基本组件。
                            这样，用户必须在不同的平台下写两套代码，而且所有能力仍然强烈依赖 React native 开发人员暴露的接口。
                        </aside>
                    </section>
                    <section>
                        <h3>曙光 !?</h3>
                        <ul>
                            <li>整体的RN化的App</li>
                            <li>已有大量原生代码的App</li>
                            <li>平台级App</li>
                        </ul>
                        <aside class="notes">
                            1、全RN化的app, 整个app的的生命周期都是在一个view上, 系统提供的各种把控都用不上, 导航如何处理? 之前原生
                               方案中的一些页面变换全部用不上,现在只有一个view

                            2、部门页面使用react话,比如经常需要运营要改变的页面, 这样势必出现多bundle问题, 以及 bundle中js 和外部
                               App中的native代码交互问题, 甚至一些样式一致问题, 比如 loading效果。

                            3、降低开发者门槛,构建自己的开发接口,让开发者用js来写功能组件, 淘宝? 微信? 微博? 小米,米UI。
                        </aside>
                    </section>
                    <section>
                        <h3>QA</h3>
                        <p>我也是初学者, 如有错误,请指正 </p>
                    </section>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

                controls: true,
				history: true,
                progress: true,
                slideNumber: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
